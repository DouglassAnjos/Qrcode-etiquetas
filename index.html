<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador 3D - Intprocess</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        canvas { display: block; }
        #controls { padding: 10px; background-color: #f0f0f0; display: flex; gap: 10px; }
        #log { height: 100px; background: #eaeaea; overflow-y: auto; padding: 10px; }
        #version { text-align: center; padding: 5px; background-color: #d3d3d3; }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="fileInput" accept="application/json">
        <button onclick="resetCamera()">Redefinir Câmera</button>
        <button onclick="clearScene()">Limpar Cena</button>
    </div>
    <div id="log">Log de erros aparecerá aqui...</div>
    <div id="version">Versão 1.1.1</div>
    <script>
        let scene, camera, renderer, controls;
        let loadedMaterials = new Map();
        let loadedObjects = new Map();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight - 150);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.enableRotate = true;
            controls.enableZoom = true;
            controls.enablePan = true;
            controls.minDistance = 100;
            controls.maxDistance = 3000;
            controls.target.set(400, 250, 0);

            const light = new THREE.AmbientLight(0x404040);
            scene.add(light);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            camera.position.set(400, 250, 1500);
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        async function loadMaterial(materialData) {
            if (loadedMaterials.has(materialData.id)) {
                return loadedMaterials.get(materialData.id);
            }

            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                side: materialData.properties.side === 'double' ? THREE.DoubleSide : THREE.FrontSide,
                roughness: materialData.properties.roughness || 0.7,
                metalness: materialData.properties.metalness || 0.0
            });

            if (materialData.texture) {
                try {
                    const texture = await loadTexture(materialData.texture);
                    if (texture) {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        texture.flipY = false;
                        material.map = texture;
                        material.needsUpdate = true;
                    }
                } catch (error) {
                    logError(`Erro ao carregar textura ${materialData.texture}: ${error}`);
                }
            }

            loadedMaterials.set(materialData.id, material);
            return material;
        }

        function loadTexture(textureName) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.TextureLoader();
                loader.load(
                    `./${textureName}`,
                    (texture) => {
                        texture.needsUpdate = true;
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        resolve(texture);
                    },
                    undefined,
                    (error) => reject(error)
                );
            });
        }

        async function loadObject(objectData, materials) {
            const geometry = new THREE.BufferGeometry();
            
            if (objectData.vertices && objectData.vertices.length > 0) {
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(objectData.vertices, 3));
                
                if (objectData.uvs && objectData.uvs.length > 0) {
                    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(objectData.uvs, 2));
                } else {
                    const positions = geometry.attributes.position.array;
                    const uvs = [];
                    for (let i = 0; i < positions.length; i += 3) {
                        uvs.push(positions[i] / 1000, positions[i + 1] / 1000);
                    }
                    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                }

                if (objectData.faces && objectData.faces.length > 0) {
                    geometry.setIndex(objectData.faces);
                }

                geometry.computeVertexNormals();
            }

            const material = await loadMaterial(materials.find(m => m.id === objectData.material));
            const mesh = new THREE.Mesh(geometry, material);

            if (objectData.position) {
                mesh.position.set(...objectData.position);
            }
            if (objectData.rotation) {
                mesh.rotation.set(...objectData.rotation);
            }
            if (objectData.scale) {
                mesh.scale.set(...objectData.scale);
            }

            loadedObjects.set(objectData.name, mesh);
            return mesh;
        }

        async function loadModel(json) {
            try {
                const cleanJson = JSON.parse(JSON.stringify(json).replace(/\/\*.*?\*\//g, "").replace(/\/\/.*$/gm, ""));
                
                // Carregar materiais
                if (cleanJson.materials) {
                    for (const materialData of cleanJson.materials) {
                        await loadMaterial(materialData);
                    }
                }

                // Carregar objetos
                if (cleanJson.objects) {
                    for (const objectData of cleanJson.objects) {
                        const mesh = await loadObject(objectData, cleanJson.materials || []);
                        scene.add(mesh);
                    }
                }

                // Processar grupos
                if (cleanJson.groups) {
                    for (const groupData of cleanJson.groups) {
                        const group = new THREE.Group();
                        for (const objectName of groupData.objects) {
                            const object = loadedObjects.get(objectName);
                            if (object) {
                                group.add(object.clone());
                            }
                        }
                        if (groupData.position) {
                            group.position.set(...groupData.position);
                        }
                        if (groupData.rotation) {
                            group.rotation.set(...groupData.rotation);
                        }
                        scene.add(group);
                    }
                }

                logError("Modelo carregado com sucesso!");
            } catch (error) {
                logError(`Erro ao carregar modelo: ${error.message}`);
            }
        }

        function clearScene() {
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            loadedMaterials.clear();
            loadedObjects.clear();
            
            const light = new THREE.AmbientLight(0x404040);
            scene.add(light);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);
            
            logError("Cena limpa!");
        }

        function logError(message) {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML += `<p>${message}</p>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        document.getElementById('fileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    const json = JSON.parse(e.target.result);
                    loadModel(json);
                } catch (error) {
                    logError('Erro ao carregar o arquivo JSON: ' + error.message);
                }
            };
            reader.readAsText(file);
        });

        function resetCamera() {
            camera.position.set(400, 250, 1500);
            controls.target.set(400, 250, 0);
        }

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight - 150);
            camera.aspect = window.innerWidth / (window.innerHeight - 150);
            camera.updateProjectionMatrix();
        });

        document.addEventListener("DOMContentLoaded", function () {
            init();
        });
    </script>
</body>
</html>
