<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador 3D - Intprocess</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        canvas { display: block; }
        #controls { padding: 10px; background-color: #f0f0f0; display: flex; gap: 10px; }
        #log { height: 100px; background: #eaeaea; overflow-y: auto; padding: 10px; }
        #version { text-align: center; padding: 5px; background-color: #d3d3d3; }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="fileInput" accept="application/json">
        <button onclick="resetCamera()">Redefinir Câmera</button>
    </div>
    <div id="log">Log de erros aparecerá aqui...</div>
    <div id="version">Versão 1.0.9</div>
    <script>
        let scene, camera, renderer, controls;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight - 150);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.enableRotate = true;
            controls.enableZoom = true;
            controls.enablePan = true;
            controls.minDistance = 100;
            controls.maxDistance = 3000;
            controls.target.set(400, 250, 0);

            const light = new THREE.AmbientLight(0x404040);
            scene.add(light);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            camera.position.set(400, 250, 1500);
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function loadModel(json) {
            const cleanJson = JSON.parse(JSON.stringify(json).replace(/\/\*.*?\*\//g, "").replace(/\/\/.*$/gm, ""));

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(cleanJson.vertices, 3));
            
            // Adicionar coordenadas UV se existirem no JSON
            if (cleanJson.uvs) {
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(cleanJson.uvs, 2));
            } else {
                // Criar UVs básicas se não existirem
                const positions = geometry.attributes.position.array;
                const uvs = [];
                for (let i = 0; i < positions.length; i += 3) {
                    uvs.push(positions[i] / 1000, positions[i + 1] / 1000);
                }
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            }

            geometry.setIndex(cleanJson.faces);
            geometry.computeVertexNormals();

            // Criar material com configurações apropriadas para textura
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff, // Cor branca para não interferir com a textura
                side: THREE.DoubleSide,
                roughness: 0.7,
                metalness: 0.0
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            if (cleanJson.texture) {
                loadTexture(cleanJson.texture).then(texture => {
                    if (texture) {
                        texture.encoding = THREE.sRGBEncoding;
                        texture.flipY = false; // Tente false se a textura estiver invertida
                        material.map = texture;
                        material.needsUpdate = true;
                        logError(`Textura ${cleanJson.texture} carregada e aplicada com sucesso!`);
                    }
                }).catch(error => {
                    logError(`Erro ao carregar a textura: ${cleanJson.texture}`);
                });
            }
        }

        function loadTexture(textureName) {
            if (!textureName) return Promise.resolve(null);
            
            return new Promise((resolve, reject) => {
                const loader = new THREE.TextureLoader();
                loader.load(
                    `./${textureName}`,
                    (texture) => {
                        texture.needsUpdate = true;
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        resolve(texture);
                    },
                    undefined,
                    (error) => {
                        reject(error);
                    }
                );
            });
        }

        function logError(message) {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML += `<p>${message}</p>`;
        }

        document.getElementById('fileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    const json = JSON.parse(e.target.result);
                    loadModel(json);
                } catch (error) {
                    logError('Erro ao carregar o arquivo JSON: ' + error.message);
                }
            };
            reader.readAsText(file);
        });

        function resetCamera() {
            camera.position.set(400, 250, 1500);
            controls.target.set(400, 250, 0);
        }

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight - 150);
            camera.aspect = window.innerWidth / (window.innerHeight - 150);
            camera.updateProjectionMatrix();
        });

        document.addEventListener("DOMContentLoaded", function () {
            init();
        });
    </script>
</body>
</html>
